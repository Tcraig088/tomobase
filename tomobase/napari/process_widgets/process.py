import numpy as np
import napari
import inspect
from collections.abc import Iterable
import time
import copy as deepcopy

from qtpy.QtWidgets import QWidget, QComboBox, QLabel, QSpinBox, QHBoxLayout, QLineEdit, QVBoxLayout, QCheckBox, QPushButton, QGridLayout, QDoubleSpinBox
from qtpy.QtCore import Qt

from abc import ABC, abstractmethod

from tomobase.log import logger
from tomobase.data import Volume, Sinogram
from tomobase.registrations.datatypes import TOMOBASE_DATATYPES
from tomobase.registrations.tiltschemes import TOMOBASE_TILTSCHEMES
from tomobase.napari.components import CollapsableWidget
from tomobase.napari.layer_widgets.layerselect import LayerSelctWidget
from tomobase.napari.utils import get_value, get_widget, connect

from threading import Thread

from napari.qt.threading import create_worker


class ProcessWidget(QWidget):
    def __init__(self, process:dict, viewer: 'napari.viewer.Viewer', parent=None):
        super().__init__(parent)
        # Define Properties
        self.selected_layer = None # Layer selected by the user
        self.layers = [] # Intermediary layers generated by the process used for class processes only
        self.viewer = viewer
        self.process = process['controller'].controller
        self.name = process['name']
    
        self.isinitialized = False
        self.isrunning = False
        
        #Setup widgets and layouts
        self.button_confirm = QPushButton('Confirm')
        self.button_initialize = QPushButton('Initialize')
        self.button_initialize.setVisible(False)
        self.custom_widgets = {
            'Name': [],
            'Label': [],
            'Widget': []
        }

        self.selected_widget = None
        if inspect.isclass(self.process):
            self.setupFromClass()
        else:
            self.setupFromFunc()
        
        self.layout = QGridLayout()
        self.layout.addWidget(self.layer_select, 0, 0 , 1, 2)
        self.layout.addWidget(self.button_initialize, 1, 0)
               
        i=2
        for j, key in enumerate(self.custom_widgets['Name']):
            self.layout.addWidget(self.custom_widgets['Label'][j], j+i, 0)
            self.layout.addWidget(self.custom_widgets['Widget'][j], j+i, 1)
        i +=i
        
        
        self.layout.addWidget(self.button_confirm, i+2, 0)
        self.layout.setAlignment(Qt.AlignTop)
        self.setLayout(self.layout)
        
        # Connect Signals
        self.button_confirm.clicked.connect(self.onConfirm)
        self.button_initialize.clicked.connect(self.initializeClass)
        
    def setupFromFunc(self):
        signature = inspect.signature(self.process)
        banned = ['self','sino', 'vol', 'kwargs']
        
        first_param = next(param for name, param in signature.parameters.items() if name != 'self')
        logger.debug(f'First param: {first_param}')
        self.layer_select = LayerSelctWidget([first_param.annotation.get_type_id()], True, self.viewer)

        for name, param in signature.parameters.items():
            if name not in banned:
                wname, wlabel, widget = get_widget(name, param)
                if wname is not None:
                    self.custom_widgets['Widget'].append(widget)
                    self.custom_widgets['Name'].append(wname)
                    self.custom_widgets['Label'].append(wlabel)
    
    def setupFromClass(self):
        signature = inspect.signature(self.process.__init__)
        first_param = next(param for name, param in signature.parameters.items() if name != 'self')
        self.layer_select = LayerSelctWidget([first_param.annotation.get_type_id()], True, self.viewer)
        
        self.button_initialize.setVisible(True)
        banned = ['self', 'sino', 'vol','kwargs']
        for name, param in signature.parameters.items():
            if name not in banned:
                wname, wlabel, widget = get_widget(name, param)
                if wname is not None:
                    self.custom_widgets['Widget'].append(widget)
                    self.custom_widgets['Name'].append(wname)
                    self.custom_widgets['Label'].append(wlabel)
        
    def initializeClass(self):
        if self.isinitialized:
            return
        
        self.isinitialized = True
        self.selected_layer = self.layer_select.getLayer()
        
        if self.selected_layer is not None:
            if self.selected_layer.metadata['ct metadata']['type'] == TOMOBASE_DATATYPES.VOLUME.value():
                input = Volume.from_data_tuple(self.selected_layer)  
                dict_args = {'vol':input}
            elif self.selected_layer.metadata['ct metadata']['type'] == TOMOBASE_DATATYPES.SINOGRAM.value():
                input = Sinogram.from_data_tuple(self.selected_layer)
                dict_args = {'sino':input}
                
        for i, key in enumerate(self.custom_widgets['Name']):
            dict_args[self.custom_widgets['Name'][i]] = get_value(self.custom_widgets['Widget'][i])
            
        self.process = self.process(**dict_args)
        presets = self.process.generate()
        
        for widget in self.custom_widgets['Widget']:
            connect(widget, self.update)
        
        self.layers = []
        if not isinstance(presets, Iterable):
            presets = [presets]
            
        for i in presets:
            if isinstance(i, Sinogram):
                self.viewer.dims.ndisplay = 2
            elif isinstance(i, Volume):
                self.viewer.dims.ndisplay = 3
                
                layerdata = i.to_data_tuple()
                layer = self.viewer._add_layer_from_data(*layerdata)
                self.layers.append(*layer)
       
    @abstractmethod
    def validate(self):
        pass
     
    def onConfirm(self):
        if self.validate():
            
    def update(self):
        if self.threaded_update_worker is None:
            for i, key in enumerate(self.custom_widgets['Name']):
                setattr(self.process, self.custom_widgets['Name'][i], get_value(self.custom_widgets['Widget'][i]))  
            
            self.threaded_update_worker = create_worker(self.process.update)
            self.threaded_update_worker.start()
            self.threaded_update_worker.returned.connect(self.updateTempLayers)
            
            
    def updateTempLayers(self, outputs):
        if self.threaded_update_worker is not None:
            self.threaded_update_worker.returned.disconnect(self.updateTempLayers)
            self.threaded_update_worker = None
        
        self.threaded_update_worker = None
        if not isinstance(outputs, Iterable):
            outputs = [outputs]
        for i, layer in enumerate(self.layers):
            layer.data = outputs[i]._transpose_to_view(use_copy=True)
            layer.refresh()
            
