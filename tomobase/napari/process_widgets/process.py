import numpy as np
import napari
import inspect
from collections.abc import Iterable
import time
import copy as deepcopy

from qtpy.QtWidgets import QWidget, QComboBox, QLabel, QSpinBox, QHBoxLayout, QLineEdit, QVBoxLayout, QCheckBox, QPushButton, QGridLayout, QDoubleSpinBox
from qtpy.QtCore import Qt

from abc import ABC, abstractmethod

from tomobase.log import logger
from tomobase.data import Volume, Sinogram
from tomobase.registrations.datatypes import TOMOBASE_DATATYPES
from tomobase.registrations.tiltschemes import TOMOBASE_TILTSCHEMES
from tomobase.napari.components import CollapsableWidget
from tomobase.napari.layer_widgets.layerselect import LayerSelctWidget
from tomobase.napari.utils import get_value, get_widget, connect

from threading import Thread

from napari.qt.threading import create_worker


class ProcessWidget(QWidget):
    def __init__(self, process:dict, viewer: 'napari.viewer.Viewer', parent=None):
        super().__init__(parent)
        # Define Properties
        self.selected_layer = None # Layer selected by the user
        self.layers = [] # Intermediary layers generated by the process used for class processes only
        self.viewer = viewer
        self.process = process['controller'].controller
        self.name = process['name']
    
        self.isinitialized = False
        self.isrunning = False
        
        #Setup widgets and layouts
        self.button_confirm = QPushButton('Confirm')
        self.button_initialize = QPushButton('Initialize')
        self.button_initialize.setVisible(False)
        self.custom_widgets = {
            'Name': [],
            'Label': [],
            'Widget': []
        }

        self.selected_widget = None
        if inspect.isclass(self.process):
            self.setupFromClass()
        else:
            self.setupFromFunc()
        
        self.layout = QGridLayout()
        self.layout.addWidget(self.selected_widget, 0, 0 , 1, 2)
        self.layout.addWidget(self.button_initialize, 1, 0)
               
        i=2
        for j, key in enumerate(self.custom_widgets['Name']):
            self.layout.addWidget(self.custom_widgets['Label'][j], j+i, 0)
            self.layout.addWidget(self.custom_widgets['Widget'][j], j+i, 1)
        i +=i
        
        
        self.layout.addWidget(self.button_confirm, i+2, 0)
        self.layout.setAlignment(Qt.AlignTop)
        self.setLayout(self.layout)
        
        # Connect Signals
        self.button_confirm.clicked.connect(self.onConfirm)
        self.button_initialize.clicked.connect(self.initializeClass)
        
    def setupFromFunc(self):
        signature = inspect.signature(self.process)
        banned = ['self','sino', 'vol', 'kwargs']
        
        first_param = next(param for name, param in signature.parameters.items() if name != 'self')
        logger.debug(f'First param: {first_param}')
        self.selected_widget = LayerSelctWidget([first_param.annotation.get_type_id()], True, self.viewer)

        for name, param in signature.parameters.items():
            if name not in banned:
                wname, wlabel, widget = get_widget(name, param)
                if wname is not None:
                    self.custom_widgets['Widget'].append(widget)
                    self.custom_widgets['Name'].append(wname)
                    self.custom_widgets['Label'].append(wlabel)
    
    def setupFromClass(self):
        signature = inspect.signature(self.process.__init__)
        first_param = next(param for name, param in signature.parameters.items() if name != 'self')
        self.selected_widget = LayerSelctWidget([first_param.annotation.get_type_id()], True, self.viewer)
        
        self.button_initialize.setVisible(True)
        banned = ['self', 'sino', 'vol','kwargs']
        for name, param in signature.parameters.items():
            if name not in banned:
                wname, wlabel, widget = get_widget(name, param)
                if wname is not None:
                    self.custom_widgets['Widget'].append(widget)
                    self.custom_widgets['Name'].append(wname)
                    self.custom_widgets['Label'].append(wlabel)
        
    def initializeClass(self):
        if self.isinitialized:
            return
        
        self.isinitialized = True
        self.selected_layer = self.selected_widget.getLayer()
        
        if self.selected_layer is not None:
            if self.selected_layer.metadata['ct metadata']['type'] == TOMOBASE_DATATYPES.VOLUME.value():
                input = Volume.from_data_tuple(self.selected_layer)  
                dict_args = {'vol':input}
            elif self.selected_layer.metadata['ct metadata']['type'] == TOMOBASE_DATATYPES.SINOGRAM.value():
                input = Sinogram.from_data_tuple(self.selected_layer)
                dict_args = {'sino':input}
                
        for i, key in enumerate(self.custom_widgets['Name']):
            dict_args[self.custom_widgets['Name'][i]] = get_value(self.custom_widgets['Widget'][i])
            
        self.process = self.process(**dict_args)
        presets = self.process.generate()
        
        for widget in self.custom_widgets['Widget']:
            connect(widget, self.runUpdate)
        
        self.layers = []
        if not isinstance(presets, Iterable):
            presets = [presets]
            
        for i in presets:
            if isinstance(i, Sinogram):
                self.viewer.dims.ndisplay = 2
            elif isinstance(i, Volume):
                self.viewer.dims.ndisplay = 3
                
                layerdata = i.to_data_tuple()
                layer = self.viewer._add_layer_from_data(*layerdata)
                self.layers.append(*layer)
       
        self.worker = create_worker(self.runUpdateThread)
        self.worker.returned.connect(self.onUpdateComplete)
        
    def validate(self):
        return True
     
    def onConfirm(self):
        if not self.validate():
            return
        
        worker = create_worker(self.runProcess)
        worker.start()
        worker.returned.connect(self.onProcessComplete)
    
    def onProcessComplete(self, obj):
        if obj is None:
            pass
        else:
            layerdata = obj.to_data_tuple(attributes={'name': self.selected_layer.name + ' ' + self.name})
            if isinstance(obj, Sinogram):
                self.viewer.dims.ndisplay = 2
            elif isinstance(obj, Volume):
                self.viewer.dims.ndisplay = 3
            self.viewer._add_layer_from_data(*layerdata)
        
    
    def runProcess(self):
        
        if inspect.isclass(self.process):
            pass
        else: 
            self.selected_layer = self.selected_widget.getLayer()
            
        layertype_id = self.selected_layer.metadata['ct metadata']['type']
        layertype = TOMOBASE_DATATYPES.key(layertype_id).capitalize()
        class_ = globals().get(layertype)
        obj = class_.from_data_tuple(self.selected_layer)


        values = {}
        for i, key in enumerate(self.custom_widgets['Name']):
            values[key] = get_value(self.custom_widgets['Widget'][i])  
            
        if inspect.isclass(self.process):
            process = self.process.apply
        else:
            process = self.process

 
        outs = process(obj, **values)
        if 'extend_returns' in values:
            if values['extend_returns'] == True:
                obj = outs.pop(0)
            else:
                obj = outs
        else:
            obj = outs
        
        logger.info(f'Process {self.name} completed')  
        if 'inplace' in values:
            if values['inplace'] == True:
                self.selected_layer.refresh()
                return
        
        return obj
        
    def runUpdate(self):
        if self.isrunning:
            return

        for i, key in enumerate(self.custom_widgets['Name']):
            setattr(self.process, self.custom_widgets['Name'][i], get_value(self.custom_widgets['Widget'][i]))  
            
        self.worker.start()


    def runUpdateThread(self):
        outputs = self.process.update()
        if not isinstance(outputs, Iterable):
            outputs = [outputs]  
        return outputs
            
    def onUpdateComplete(self, values):
        self.isrunning = False
        for i, layer in enumerate(self.layers):
            layer.data = values[i]._transpose_to_view(use_copy=True)
            layer.refresh()
